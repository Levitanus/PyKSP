from collections import OrderedDict

# from k_built_ins import all_callbacks
from k_built_ins import BuiltInFuncInt
from k_built_ins import BuiltInFuncStr
from k_built_ins import NI_ASYNC_ID
from k_built_ins import InitCallback
from k_built_ins import UiUpdateCallback
from k_built_ins import UiControlCallback
from k_built_ins import PgsCallback
from k_built_ins import bPathVar

from base_types import KspArray
# LOAD_SAVE_COMMANDS


class GetFolder(BuiltInFuncStr):

    def __init__(self):
        super().__init__('get_folder',
                         args=OrderedDict(path_var=bPathVar),
                         def_ret='path')

    def __call__(self, path_var: bPathVar):
        '''returns the path specified with the built-in path variable
        <path-variable>
        the following path variables are available:
        $GET_FOLDER_LIBRARY_DIR
        if used with an nki belonging to an encoded library:
            library folder
        if used with an unencoded nki: the user content directory
        $GET_FOLDER_FACTORY_DIR
        the factory folder of KONTAKT (mainly used for loading factory
        IR samples)
        Note: this is not the factory library folder!
        $GET_FOLDER_PATCH_DIR
        the directory in which the patch was saved.
        If the patch was not saved before, an empty string is returned.'''
        return super().__call__(path_var)


get_folder = GetFolder().__call__


class LoadArray(BuiltInFuncInt):

    def __init__(self):
        super().__init__('load_array',
                         args=OrderedDict(array=KspArray,
                                          mode=int),
                         def_ret=NI_ASYNC_ID,
                         callbacks=(InitCallback,
                                    UiUpdateCallback,
                                    UiControlCallback,
                                    PgsCallback))

    def __call__(self, array: KspArray, mode: int):
        '''loads an array from an external file (.nka file)
        <array-variable>
        the array variable, this name must be present in the .nka file
        <mode>
        0: A dialog window pops up, allowing you to select an .nka file.
        Can only be used in ui, pgs and persistence_changed callbacks.
        1: The array is directly loaded from the "Data" folder.
        For user instruments, the "Data" folder is located beside the
        resource container.
        For library instruments, the "Data" folder is located here:
        OS X: <UserName>/Library/Application Support/<Library Name>/
        Win: C:/User/<UserName>/AppData/Local/<Library Name>\
        Can be used in ui, pgs, init (synchronous) and persistence_changed
        callbacks.
        2: The array is directly loaded from the "data" folder inside
        the resource container. Can be used in ui, pgs, init (synchronous)
        and persistence_changed callbacks.
        Remarks
        • It is also possible to load string arrays from .nka files.
        • It is not possible to load an array with %xyz in its .nka file
            into array %abc.
        • The array data is not directly available after the load_array()
            command has been executed since the command works
            asynchronous. The only situation in which the values are
            instantly available is when using mode 1 or mode 2 within
            an init callback.
        • When using mode 0 the callback continues even if the loading
            dialog is still open.
        • Mode 2 is only available for loading arrays,
            i.e. save_array() does not have this option.
        • When loading an array within the init callback, please
            remember that the loaded data will be overwritten at the end
            of the callback if the array is persistent.
            Use read_persistent_var() before loading the array to
            avoid this problem.
        • .nka files loaded from the resource container should always
            have a newline character at the end of the file.
            If this last newline is missing, then KONTAKT will not know
            the file has ended and will continue to try and load other
            data from the resources container. Files generated by the
            save_array() command have this automatically, but if you are
            creating files manually, then this is something to
            take care of.'''
        return super().__call__(array, mode)


load_array = LoadArray().__call__


class LoadArrayStr(BuiltInFuncInt):

    def __init__(self):
        super().__init__('load_array_str',
                         args=OrderedDict(array=KspArray,
                                          path=str),
                         def_ret=NI_ASYNC_ID,
                         callbacks=(InitCallback,
                                    UiUpdateCallback,
                                    UiControlCallback,
                                    PgsCallback))

    def __call__(self, array: KspArray, path: str):
        '''loads an array from an external file (.nka file) using
        the file's absolute path
        <array-variable>
        the array variable, this name must be present in the .nka file
        <path>
        the absolute path of the .nka file
        Remarks
        • The behaviour is similar to load_array()with mode set to 0,
        but instead of manually choosing an .nka file you can specify
        it with an absolute path.
        • Can be used in init (synchronous), persistence_changed,
        ui and pgs callbacks.'''
        return super().__call__(array, path)


load_array_str = LoadArrayStr().__call__


class LoadIrSample(BuiltInFuncInt):

    def __init__(self):
        super().__init__('load_ir_sample',
                         args=OrderedDict(path=str,
                                          slot=int,
                                          generic=int),
                         def_ret=NI_ASYNC_ID,
                         callbacks=(InitCallback,
                                    UiUpdateCallback,
                                    UiControlCallback,
                                    PgsCallback))

    def __call__(self, path: str, slot: int, generic: int):
        '''loads an impulse response sample into KONTAKT's convolution
        effect
        <file-path>
        the absolute file path of the IR sample
        If no path is specified, the command will look for the
        specified sample within the “ir_samples” folder of the
        Resource Container.
        If no Resource Container is available, the folder "ir_samples"
        within the KONTAKT user folder will be checked.
        The KONTAKT user folder is loacated here:
        OS X
        /Users/<username>/Documents/Native Instruments/Kontakt 5/
        Windows
        C:/Users/<username>/Documents/Native Instruments/Kontakt 5/
        <slot>
        the slot index of the convolution effect (zero-based)
        <generic>
        specifies whether the convolution effect is used as an
        1: Insert Effect
        0: Send Effect
        For busses, this parameter specifies the actual bus:
        $NI_BUS_OFFSET + [0-15] one of the 16 busses
        Remarks
        • Please note that sub directories inside the "ir_samples"
        folder will not be scanned and it is not recommended to add
        them manually via text strings. Doing so could lead to problems
        because subfolders are being ignored during the creation of a
        Resource Container monolith.'''
        return super().__call__(path, slot, generic)


load_ir_sample = LoadIrSample().__call__


class SaveArray(BuiltInFuncInt):

    def __init__(self):
        super().__init__('save_array',
                         args=OrderedDict(array=KspArray,
                                          mode=int),
                         def_ret=NI_ASYNC_ID,
                         callbacks=(InitCallback,
                                    UiUpdateCallback,
                                    UiControlCallback,
                                    PgsCallback))

    def __call__(self, array: KspArray, mode: int):
        '''saves an array to an external file (i.e. an .nka file)
        <array-variable>
        the array to be saved
        <mode>
        0: A dialog window pops up, allowing you to save the .nka file.
        Can only be used in ui, pgs and persistence_changed callbacks.
        1: The array is directly loaded from the "Data" folder.
        For user instruments, the "Data" folder is located beside
        the resource container.
        For library instruments, the "Data" folder is located here:
        OS X: <UserName>/Library/Application Support/<Library Name>/
        Win: C:/User/<UserName>/AppData/Local/<Library Name>\
        Can be used in ui, pgs, and persistence_changed callbacks.
        Remarks
        • It is also possible to save string arrays into .nka files.
        • The exported .nka file consists of the name of the array
        followed its values.
        • When using mode 0 the callback continues even if the loading
        dialog is still open.'''
        return super().__call__(array, mode)


save_array = SaveArray().__call__


class SaveArrayStr(BuiltInFuncInt):

    def __init__(self):
        super().__init__('save_array_str',
                         args=OrderedDict(array=KspArray,
                                          path=str),
                         def_ret=NI_ASYNC_ID,
                         callbacks=(InitCallback,
                                    UiUpdateCallback,
                                    UiControlCallback,
                                    PgsCallback))

    def __call__(self, array: KspArray, path: str):
        '''saves an array to an external file (i.e. an .nka file),
        using the specified absolute path
        <array-variable>
        the array to be saved
        <path>
        the absolute path of the .nka file to be saved
        Remarks
        • The behaviour is similar to save_array(), but instead of
        manually choosing a save location, you can directly save the
        file to the specified location.
        • If the file does not exist (but the folder does), a new .nka
        file will be created
        • Can be used in persistence_changed, ui and pgs callbacks.'''
        return super().__call__(array, path)


save_array_str = SaveArrayStr().__call__


class SaveMidiFile(BuiltInFuncInt):

    def __init__(self):
        super().__init__('save_midi_file',
                         args=OrderedDict(path=str),
                         def_ret=NI_ASYNC_ID,
                         callbacks=(InitCallback,
                                    UiUpdateCallback,
                                    UiControlCallback,
                                    PgsCallback))

    def __call__(self, path: str):
        '''saves a MIDI file with a range specified by the
        mf_set_export_area() command.
        <path>
        the absolute path of the MIDI file'''
        return super().__call__(path)


save_midi_file = SaveMidiFile().__call__
